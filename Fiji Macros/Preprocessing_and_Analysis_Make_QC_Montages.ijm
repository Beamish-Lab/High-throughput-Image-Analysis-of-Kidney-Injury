macro "Preprocessing_and_Analysis_Make_QC_Montages" {

/*
Makes QC montage images of the raw images or segmentations for each channel
The segmentations should have been generated by prior macros in this pipeline so that have the file name form:
form: genotype_reporter_sex_tag_condition_channel..other info; for example: the "WT_GFP_M_0001_FA2_Ki67_SEGMENTATION_(Ki67).zip‚Äù
Also requires that the outlines have been completed (these can be checked as well) for example "WT_GFP_M_0001_FA2.roi"

NOTE: by default this macro will sort and group the images by the first (genotype) and fifth (condition) parts of the name.
this can be changed in lines 139 and 140 below.

Assumes there are up to 4 channels to check
Will work either for segmentations (which have a sub-directory called "Segmentation" in it generated by the batch processing) or for the raw images (with no segmentation directory)

*/

//make sure the that data tables generate copy all the header and index rows/columns into excel
run("Input/Output...", "jpeg=85 gif=-1 file=.csv copy_column copy_row save_column save_row");

setBatchMode(false);
//setBatchMode(true);//runs without showing the files that are opened to speed things up

//make sure expandable arrays are available
setOption("ExpandableArrays",true);

//clear everything out before starting
run("Close All");

if(isOpen("Results")){
	selectWindow("Results");
	run("Close");
}

run("ROI Manager...");
if (RoiManager.size!=0) { 
		roiManager("Deselect");  
		roiManager("Delete"); 
}

//make a time stamp
time_stamp = Make_Time_Stamp();

//set the default path
default_source_path = "enter path here";

//get the directories needed
Dialog.create("Processing Setup");
Dialog.addMessage("SEGMENTATION SOURCE DIRECTORIES (Choose the master directory")
Dialog.addCheckbox("Include DAPI:", true);
Dialog.addDirectory("DAPI:",default_source_path+"+\\DAPI\\");
Dialog.addCheckbox("Include Channel 1:", true);
Dialog.addDirectory("Channel 1: ",default_source_path+"+\\Channel 1\\");
Dialog.addCheckbox("Include Channel 2:", true);
Dialog.addDirectory("Channel 2: ",default_source_path+"+\\Channel 2\\");
Dialog.addCheckbox("Include Channel 3:", true);
Dialog.addDirectory("Channel 3: ",default_source_path+"+\\Channel 3\\");
Dialog.addCheckbox("Include outlines in analysis:", true);
Dialog.addMessage("OTHER DIRECTORIES:")
Dialog.addDirectory("Section Outline Director (ignored if not using outlines): ",default_source_path+"+\\CORTEX ONLY OUTLINES\\")
Dialog.show();

//extract the data from the user interface
use_DAPI_flag = Dialog.getCheckbox();
DAPI_directory = Dialog.getString();
use_C1_flag = Dialog.getCheckbox();
C1_directory= Dialog.getString();
use_C2_flag = Dialog.getCheckbox();
C2_directory= Dialog.getString();
use_C3_flag = Dialog.getCheckbox();
C3_directory= Dialog.getString();
use_outlines_flag = Dialog.getCheckbox();
section_outline_directory = Dialog.getString();

//check the files
use_flag_array = newArray(use_DAPI_flag,use_C1_flag,use_C2_flag,use_C3_flag,use_outlines_flag);
directory_array = newArray(DAPI_directory,C1_directory,C2_directory,C3_directory,section_outline_directory);
IsOK = 0;
error_flag = 0;
for(aa=0;aa<directory_array.length-1;aa++){
	for(bb=aa+1;bb<directory_array.length;bb++) {
		if(use_flag_array[aa]&&use_flag_array[bb]){
			//check to see if the directories are segmentation directories or not
			compare_directory1 = CheckForSegmentationFolder(directory_array[aa]);
			compare_directory2 = CheckForSegmentationFolder(directory_array[bb]);
			IsOK = CompareDirectories(compare_directory1,compare_directory2);
			if(IsOK!=0){
				error_flag++;
			}

		} 
	}
	
	//store the number of files to use for later (this will be the same for all iterations assuming the there are now errors)
	if(use_flag_array[aa]) { //note that this macro will not work to make a montage only of outlines
		compare_directory1 = CheckForSegmentationFolder(directory_array[aa]);
		last_used_directory = directory_array[aa]; //note the last used directory in the list, will use this to build the output
		last_used_file_list = getFileList(compare_directory1);
		number_of_files = last_used_file_list.length;
	}
}

//make the output directory
root_directory = Directory_Up_One_Level(last_used_directory);
output_directory_root = root_directory + "QC_montages(" + time_stamp + ")\\";
File.makeDirectory(output_directory_root);

if(error_flag!=0){
	showMessage("Matching error, check files");
	exit;
}

/////////////////////////////////////////////////////////////////
//Setup analysis
/////////////////////////////////////////////////////////////////

if(use_outlines_flag) outlines_to_process=getFileList(section_outline_directory);//make a list of the files that need to be processed

//make a table of the data for each of the files
genotype = newArray(number_of_files);
reporter = newArray(number_of_files);
sex = newArray(number_of_files);
tag = newArray(number_of_files);
condition = newArray(number_of_files);

for(aa=0;aa<number_of_files;aa++){
	//extract the various parts of the file name to sort the table more easily later
	current_file = File.getNameWithoutExtension(last_used_file_list[aa]); //using the last file list from above, assuming not errors)
	current_file_components = split(current_file, "_"); //break up the input file name by the _ parts. The files should be of the form form genotype_reporter_sex_tag__condition_channel_otherinfo, we keep only the first 5 of these.
	genotype[aa] = current_file_components[0];
	reporter[aa] = current_file_components[1];
	sex[aa] = current_file_components[2];
	tag[aa] = current_file_components[3];		
	condition[aa] = current_file_components[4];
}

////////////////////////////////////////////////////////////////////////////////

//set up the ordering for the files and ask the user how to set up the montages
level1_array = condition;
level2_array = genotype;

unique_level1_elements = Find_Unique_Elements(level1_array);
unique_level2_elements = Find_Unique_Elements(level2_array);
n_level1 = unique_level1_elements.length;
n_level2 = unique_level2_elements.length;

group_names = newArray(n_level1*n_level2);
group_numbers = newArray(n_level1*n_level2);

//make a list of the different combinations of level1 and level2 and how many images of each there are
index = 0;
for(aa=0;aa<n_level1;aa++){
	for(bb=0;bb<n_level2;bb++){
		group_names[index] = unique_level2_elements[bb] + "_" +  unique_level1_elements[aa];
		group_numbers[index]=Find_Instance_Number(level1_array,unique_level1_elements[aa],level2_array,unique_level2_elements[bb]);
		index++;
	}
}

//show the user how many combinations that were detected and how many images of each there were
Dialog.create("Processing Setup");
Dialog.addMessage("Groups detected:");
for (i = 0; i < n_level1*n_level2; i++) {
	Dialog.addMessage(group_names[i]+": " + group_numbers[i] + " images");
}

max_images = FindArrayMax(group_numbers);
recommended_dimensions = FindRowsColumns(max_images);

//ask the user how to make the montages
Dialog.addNumber("Enter the number or rows for the montage",recommended_dimensions[0]);
Dialog.addNumber("Enter the number or columns for the montage",recommended_dimensions[1]);
Dialog.show();

n_rows = Dialog.getNumber();
n_columns = Dialog.getNumber();

////////////////////////////////////////
//MAKE THE MONTAGE IMAGES
////////////////////////////////////////

downscale_fraction = 0.2; //this is the default (0.27 can be used for slightly higher resolution and still meets the minimum in general)

//loop through each channel
for(ii=0;ii<4;ii++) {

	if(use_flag_array[ii]){ //run only if checked

		//for each loop set up the parameters
		image_directory = CheckForSegmentationFolder(directory_array[ii]);
		image_filename_array = getFileList(image_directory);
		image_marker = GetMarker(image_directory);
		output_directory = output_directory_root+image_marker+"\\";
		File.makeDirectory(output_directory);
		
		//open the files
		n_image_files = image_filename_array.length;
		files_not_included = newArray(0);
		for(aa=0;aa<n_level1;aa++){
			for(bb=0;bb<n_level2;bb++){
				current_level1 = unique_level1_elements[aa];
				current_level2 = unique_level2_elements[bb];
				current_group_name = current_level2 + "_" +  current_level1;
				
				current_group_files_processed = 0;
				n_files_not_included = 0;
				for(cc=n_image_files-1;cc>=0;cc--) {  //the default sort order is smallest to largest so work backward from largest to smallest
					
					//only open the files that match the current group
					if((current_level1==level1_array[cc])&&(current_level2==level2_array[cc])) {
						if(current_group_files_processed > n_rows*n_columns){
							files_not_included[n_files_not_included] = image_filename_array[cc];
							n_files_not_included++;			
						} else {
							current_image = image_filename_array[cc];
							if(use_outlines_flag) current_outline = outlines_to_process[cc];
							open(image_directory+current_image);
							current_image_title = getTitle();
							width = getWidth();
							height = getHeight();
							
							if(use_outlines_flag){
								//add the outline and clear the outside
								roiManager("Open",section_outline_directory+current_outline);
								roiManager("Select", 0);
								roiManager("Set Color", "magenta");
								roiManager("Set Line Width", 25);
								run("Clear Outside");
								run("From ROI Manager");	
								
								//clear out the roi manager
								roiManager("reset")			
							}
							
							//make the images all with an upright kidney
							if(width>height){
								run("Rotate 90 Degrees Right");
							}
							
							getPixelSize(unit, pw, ph, pd);
		
							
							run("Scale...", "x="+downscale_fraction+" y="+downscale_fraction+" create");  // other optiosn: interpolation=Bilinear average
							scaled_image_title = getTitle();
		
							selectWindow(current_image_title);
							run("Close");
							
							//adjust the brightness and contrast
							selectWindow(scaled_image_title);
							if(IsSegmentation(image_directory)){
								setMinAndMax(0, 1);
							} else {
								setMinAndMax(0,60);	//can adjust as needed, this works for most images																																																							
							}
													
							//save the pixel size before the image data is lost when converted to rgb
							getPixelSize(unit, pw, ph, pd);
										
							run("Flatten"); //EMBED the roi
							flattened_output_image_title = getTitle();
		
							selectWindow(scaled_image_title);
							run("Close");
							
							selectWindow(flattened_output_image_title);
							rename(current_image);
												
							current_group_files_processed++;
						}		
					}
				}
				
				//now make and save the images if there are any in the group, otherwise just go to the next group. 
				if(current_group_files_processed>0) {
					
					//make a montage only if there are more than 1 images open, otherwise just save the single image as a jpeg
					if(current_group_files_processed>1){
						run("Images to Stack", "method=[Copy (center)] name=Stack title=[] use");
						run("Make Montage...", "columns="+n_columns+" rows="+n_rows+" scale=1 font=50 label");
							
						selectWindow("Stack");
						close();
						selectWindow("Montage");
					} 
					
					pixel_per_micron = 1/pw; //stored after downscalling above
					pixel_per_micron_string = d2s(pixel_per_micron,4);
			
					//add scale bar
					run("Set Scale...", "distance="+pixel_per_micron_string+" known=0.001 pixel=1.000 unit=mm");
					run("Scale Bar...", "width=2 height=50 font=200 color=White background=None location=[Lower Right] bold overlay");
			
					//save
					output_file_name = image_marker + "_" + current_group_name + ".jpg";
					saveAs("JPEG", output_directory + output_file_name);
				}
				//clean up
				run("Close All");
				
			}
		}
	}
}

selectWindow("ROI Manager");
run("Close");

print("COMPLETE.  Files saved to:\n"+output_directory_root);

}

function CompareDirectories(directory1,directory2) { 
	// make sure the file lists in the two directories match in the first 5 parts of the name in the form:
	//Genotype_Reporter_Sex_Tag_Condition_Marker_other info 
	//for example "WT_GFP_M_0001_FA2_Ki67_SEGMENTATION_(Ki67).zip‚Äù root is "WT_GFP_M_0001_FA2"

	directory1_to_process = getFileList(directory1); 
	directory2_to_process = getFileList(directory2);
	mismatch_flag = 0;
	
	//check that the directories have the same number of files
	if(directory1_to_process.length!=directory2_to_process.length){
		mismatch_flag = 1;
		print("NUMBER OF FILES IN DIRECTORIES DO NOT MATCH:\nDIRECTORY 1:\n" + directory1 + "\nDIRECTORY 2:\n" + directory2);
	} else {
		number_of_files = directory1_to_process.length;
		for (cc=0; cc<number_of_files; cc++) {
		
			//find the directory 1 file name root
			directory1_file=File.getNameWithoutExtension(directory1_to_process[cc]);
			directory1_ID_components = split(directory1_file, "_"); //break up the input file name by the _ parts. The files should be of the form form genotype_reporter_sex_tag__condition_channel_otherinfo, we keep only the first 5 of these.
			directory1_ID_components = Array.slice(directory1_ID_components,0,5); //extract only the root of the filename (the last index is NOT included)
			directory1_ID = String.join(directory1_ID_components,"_");//join the components back together to generate the filename root
		
			//find the directory 2 file name root
			directory2_file=File.getNameWithoutExtension(directory2_to_process[cc]);
			directory2_ID_components = split(directory2_file, "_"); //break up the input file name by the _ parts. The files should be of the form form genotype_reporter_sex_tag__condition_channel_otherinfo, we keep only the first 5 of these.
			directory2_ID_components = Array.slice(directory2_ID_components,0,5); //extract only the root of the filename (the last index is NOT included)
			directory2_ID = String.join(directory2_ID_components,"_");//join the components back together to generate the filename root
			
			//make sure the two directory roots match		
			if(directory1_ID!=directory2_ID){
				mismatch_flag = mismatch_flag++;
				print("FILE MISMATCH ERROR:\nDirectory 1 file: " + directory1_file + " DOES NOT MATCH:\nDirectory 2 file: " + directory2_file + "\nDirectory 1:\n" + directory1 + "\nDirectory 2:\n" + directory2);
			}
		}
		return mismatch_flag; //returns zero if all match
	}
}

function Make_Time_Stamp () {
 	//makes a time stamp string
     getDateAndTime(year, month, dayOfWeek, dayOfMonth, hour, minute, second, msec);
	 time_stamp_output = ""; 
     if (month<9) {time_stamp_output = "0";}//month is a zero based index 
     time_stamp_output = time_stamp_output+ d2s(month+1,0);//month is a zero based index 
     if (dayOfMonth<10) {time_stamp_output = time_stamp_output+"0";}
     time_stamp_output = time_stamp_output+dayOfMonth;
     time_stamp_output = time_stamp_output+year+"_";
     if (hour<10) {time_stamp_output = time_stamp_output+"0";}
     time_stamp_output = time_stamp_output+hour;
     if (minute<10) {time_stamp_output = time_stamp_output+"0";}
     time_stamp_output = time_stamp_output+minute;
     return time_stamp_output;
  }
  
function Directory_Up_One_Level(directory){
 	//finds the path the the directory one level up than the input directory
 	
 	directory_components = split(directory, "\\"); 
	
	if(directory_components.length !=1) {
		one_level_up_directory_components = Array.slice(directory_components,0,directory_components.length-1); //extract the path to the source folder one level up 
		one_level_up_directory = String.join(one_level_up_directory_components,"\\")+"\\";
	} else {
		one_level_up_directory = directory; //if there is no directory one level up, then return the base directory back.
	}
	
	return one_level_up_directory;
}

function CheckForSegmentationFolder(directory) {
	//returns the base directory if there is no segmentation directory or the segmentation path if there is one
	
	directory_file_list=getFileList(directory+"Segmentation\\"); 
	n_file_list = directory_file_list.length;
	
	//if there is not a Segmentation folder, then the number of files will be 0, in which case, count the files in the original directory
	if(n_file_list==0){
		return directory;
	} else {
		return directory + "Segmentation\\";
	}

	
}

function GetMarker(directory) {
	//returns the value in the sixth position of the name which is the marker for that channel
	//for example "WT_GFP_M_0001_FA2_Ki67_SEGMENTATION_(Ki67).zip‚Äù marker is "Ki67"
	list = getFileList(directory);
	example_file = File.getNameWithoutExtension(list[0]); //assumes that all files in the directory have the same marker
	example_file_components = split(example_file,"_");
	return example_file_components[5]; //see note at beginning--input files must have the form Genotype_Reporter_Sex_Tag_Condition_Marker_other info
}

function Find_Unique_Elements(input_array){
	//finds the unique elements of an array and returns them in a new array
	
	temp_array = Array.copy(input_array);
	Array.sort(temp_array);
	output = newArray(temp_array[0]);
	index = 1;
	for (i = 1; i < temp_array.length; i++) {
		if(temp_array[i]!=temp_array[i-1]){
			output[index] = temp_array[i];
			index++;
		}
	}
return output;
}

function Find_Instance_Number(input_array1,target_element1,input_array2,target_element2){
	//finds the number of times that in two arrays of the same length the first array matches the first array target and the second array element matches the second target
	//requires that input_array1 and input_array2 have the same length
	target_element_number = 0;
	for (i = 0; i < input_array1.length; i++) {
		if((input_array1[i]==target_element1)&&(input_array2[i]==target_element2)){ 
			target_element_number++;
		}
	}
return target_element_number;
}

function Is_In_Array(array,target) {
	//looks for a target element in an array and returns 1 if it is
	in_array_flag = 0; 
	for (i = 0; i < array.length; i++) {
		if(array[i]==target){
			in_array_flag = 1;
		}
	}
	return in_array_flag;
}


function Back_Up_One_Directory_Level(input_directory){
	//outputs an array with the 0 element the directory one level up and the 1 element the last folder name
	output = newArray(2);
	input_directory_components = split(input_directory, "\\"); 
	source_last_folder_name = input_directory_components[input_directory_components.length-1]; 
	input_directory_components = Array.slice(input_directory_components,0,input_directory_components.length-1); 
	output_root_directory = String.join(input_directory_components,"\\")+"\\";

	output[0] = output_root_directory;
	output[1] = source_last_folder_name;
	return output;
}

function IsSegmentation(directory){
	//checks to see if a directory has a subfolder called "Segmentation"
	directory_components = split(directory, "\\"); 
	if(directory_components[directory_components.length-1]=="Segmentation") {
		return true;
	} else {
		return false;
	}
}

function FindRowsColumns(number){
	//generateds a recommendation for rows and columns to use for the montage
	//find lowest square
	columns = 1;
	while (Math.sqr(columns) < number) {
		columns++;
	}
	//prune the extra rows
	rows = columns;
	while (rows*columns > number) {
		rows--;
	}
	rows++;
	return newArray(rows,columns);
}

function FindArrayMax(array){
	//finds the maximum value in an array
	maximum_value = array[0];
	for (i = 1; i < array.length; i++) {
		if(array[i]>maximum_value) maximum_value=array[i];
	}
	return maximum_value;
}